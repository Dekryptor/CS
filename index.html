<html>
	<head>
	<link rel="stylesheet" type="text/css" href="styles.css">
	
	<script type="text/javascript" src="config.js"></script>
	<script type="text/javascript" src="util/PointerLock.js"></script>
	<script type="text/javascript" src="lib/gl-matrix.js"></script>
	<script type="text/javascript" src="lib/webgl-utils.js"></script>
	<script type="text/javascript" src="MapParser.js"></script>
	<script type="text/javascript" src="MapRender.js"></script>
	<script type="text/javascript" src="CollisionDetection.js"></script>
	<script type="text/javascript" src="Map.js"></script>
	<script type="text/javascript" src="Player.js"></script>
	<script type="text/javascript" src="lib/keyboard.js"></script>
	
	<script id="shader-fs" type="x-shader/x-fragment">
		//Shader for doing color stuff
		precision mediump float;
		varying vec3 forFragColor;

		void main(void) {
			gl_FragColor = vec4(forFragColor, 1.0);
		}
	</script>
	
	<script id="shader-vs" type="x-shader/x-vertex">
		//Shader for calculating positions of each vertex
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexColor;

		varying vec3 forFragColor;
		
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		//uniform mat3 uNMatrix;

		void main(void) {
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			forFragColor = aVertexColor;
		}
	</script>

	<script type="text/javascript">
		//Define namespace
		window.cs = window.cs || { };
	
		//Webgl context
		var gl;
		//For sending information to the shaders
		var shaderProgram;
		//Modelview matrix
		var mvMatrix = mat4.create();
		//Projection matrix
		var pMatrix = mat4.create();
		//Normal matrix not yet needed
		//var uNMatrix = mat3.create();
		//Hardcoded cs_assault position. TODO: Read this from the entity set
		cs.player = new cs.Player(-320, 352, 48, 5);
		//http://forums.steampowered.com/forums/showthread.php?t=1613876
	
		//Boilerplate code begin
		function initGL(canvas) {
			try {
				gl = canvas.getContext("webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
				
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.cullFace(gl.FRONT);
				
			} catch (e) { }
			if (!gl) {
				console.log("Could not initialise WebGL");
			}
		}


		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3) {
					str += k.textContent;
				}
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex") {
				shader = gl.createShader(gl.VERTEX_SHADER);
			} else {
				return null;
			}

			gl.shaderSource(shader, str);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert(gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
		}

		function initShaders() {
			var fragmentShader = getShader(gl, "shader-fs");
			var vertexShader = getShader(gl, "shader-vs");

			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert("Could not initialise shaders");
			}

			gl.useProgram(shaderProgram);

			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
			gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
			//shaderProgram.uNMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
		}

		function setMatrixUniforms() {
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
			gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
			//gl.uniformMatrix3fv(shaderProgram.uNMatrixUniform, false, uNMatrix);
		}
		//Boilerplate code end
		
		function render() {
			var player = cs.player;
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			mat4.perspective(pMatrix, cs.config.FIELD_OF_VIEW*Math.PI/180,
				gl.viewportWidth / gl.viewportHeight, cs.config.NEAR_CLIPPING, cs.config.FAR_CLIPPING);

			//Rotate the player
			mat4.identity(mvMatrix);
			mat4.rotateX(mvMatrix, mvMatrix, player.xAngle);
			mat4.rotateY(mvMatrix, mvMatrix, player.yAngle);
			
			//Move the player by moving the map in the reverse direction
			mat4.translate(mvMatrix, mvMatrix, [player.y, -player.z - cs.config.PLAYER_HEIGHT, player.x]);
			
			//Rotate the map so it matches the first person shooter style
			mat4.rotateX(mvMatrix, mvMatrix, -Math.PI/2);
			mat4.rotateZ(mvMatrix, mvMatrix, Math.PI/2);
			
			//mat4.invert(uNMatrix, mvMatrix);
			setMatrixUniforms();
			
			//Render the entire map
			cs.map.render(player.position());
		}
		
		function mainLoop() {
			requestAnimFrame(mainLoop);
			cs.player.move();
			
			render();
		}
		
		//Download the bsp file and call callback on the result
		function getMapData(callback) {
			var path = cs.config.MAP_PATH;
			var req = new XMLHttpRequest();
			req.open("GET", path, true);
			req.responseType = "arraybuffer";
			req.onreadystatechange = function () {
				if(req.readyState === 4) {
					if(req.status === 200 || req.status == 0) {
						callback(new Uint8Array(req.response));
					}
				}
			}
			req.send(null);
		}
		
		function webGLStart() {
			var canvas = document.getElementById("canvas");
			initGL(canvas);
			initShaders();
			
			getMapData(function(data) {
				//Parse map
				cs.map = new cs.Map(shaderProgram, gl, data);
				
				gl.clearColor(0.0, 0.0, 0.0, 1.0);

				//Set event handler for resizing the screen every time
				//the window changes size
				var resizeCallback = function() {
					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;
					gl.viewportWidth = window.innerWidth;
					gl.viewportHeight = window.innerHeight;
				};
				resizeCallback();
				window.addEventListener("resize", resizeCallback, false);
				
				//Listen for clicks on the canvas
				canvas.addEventListener("click", function() {
					PointerLock.requestPointerLock(canvas);
				}, false);
				
				//Listen for pointer locking
				PointerLock.addPointerLockExchangeEventListener(document, function(e) {
					//Did the pointer just go from unlocked to locked?
					if(!!PointerLock.pointerLockElement()) {
						//Yep! Add mousemove listener
						PointerLock.addMouseMoveEventListener(document, rotatePlayer, false);
					}
					else { //Nope. Remove mouse move listener
						PointerLock.removeMouseMoveEventListener(document, rotatePlayer);
					}
				}, false);
				
				mainLoop();
			});
		}
		
		//Rotate the player when the mouse is moved
		function rotatePlayer(e) {
			cs.player.rotate(e.movementX, e.movementY);
		}
	</script>
	</head>


	<body onload="webGLStart();">
		<canvas id="canvas" style="display: block; margin:0; padding:0"></canvas>
	</body>

</html>